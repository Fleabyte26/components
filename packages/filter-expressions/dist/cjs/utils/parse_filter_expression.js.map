{"version":3,"file":"parse_filter_expression.js","names":["_pegjs","require","_get_number_from_string","_get_matches_advanced_node","_transform_ast","_userAttributeTransform","_type_to_grammar","generateParser","parserCache","type","grammar","generate","parserOptions","Object","getNumberFromString","exports","parseFilterExpression","expression","userAttributes","_typeToGrammar","typeToGrammar","anyvalue","_typeToGrammar$transf","transform","root","parser","transforms","userAttributeTransform","transformAST","parse","error","getMatchesAdvancedNode"],"sources":["../../../src/utils/parse_filter_expression.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\nimport type { Parser } from 'pegjs';\nimport { generate } from 'pegjs';\nimport type {\n  FilterASTNode,\n  FilterExpressionType,\n  TransformFunction,\n  UserAttributeWithValue,\n} from '../types';\nimport { getNumberFromString } from './number/get_number_from_string';\nimport { getMatchesAdvancedNode } from './get_matches_advanced_node';\nimport { transformAST } from './transform/transform_ast';\nimport { userAttributeTransform } from './transform/userAttributeTransform';\nimport { typeToGrammar } from './type_to_grammar';\n\n/**\n * Generates a parser from a PEGjs grammar and caches the result\n */\nconst generateParser = (() => {\n  const parserCache: { [key: string]: Parser } = {};\n  return (type: string, grammar: string) => {\n    if (!parserCache[type]) {\n      parserCache[type] = generate(grammar);\n    }\n    return parserCache[type];\n  };\n})();\n\n/**\n * Variables used inside grammars\n */\nexport const parserOptions = { Object, getNumberFromString };\n\n/**\n * A functions that uses a grammar of type type to parse an expression and returns an AST\n */\nexport const parseFilterExpression = (\n  type: FilterExpressionType,\n  expression: string,\n  userAttributes?: UserAttributeWithValue[]\n): FilterASTNode => {\n  const {\n    grammar,\n    anyvalue,\n    transform = (root: FilterASTNode) => root,\n  } = typeToGrammar(type);\n  if (expression === '') {\n    return anyvalue;\n  }\n  try {\n    const parser = generateParser(type, grammar);\n    const transforms: TransformFunction[] = [\n      userAttributeTransform(userAttributes),\n      transform,\n    ];\n    return transformAST(parser.parse(expression, parserOptions), transforms);\n  } catch (error) {\n    return getMatchesAdvancedNode(expression);\n  }\n};\n"],"mappings":";;;;;;AAKA,IAAAA,MAAA,GAAAC,OAAA;AAOA,IAAAC,uBAAA,GAAAD,OAAA;AACA,IAAAE,0BAAA,GAAAF,OAAA;AACA,IAAAG,cAAA,GAAAH,OAAA;AACA,IAAAI,uBAAA,GAAAJ,OAAA;AACA,IAAAK,gBAAA,GAAAL,OAAA;AAKA,IAAMM,cAAc,GAAI,YAAM;EAC5B,IAAMC,WAAsC,GAAG,CAAC,CAAC;EACjD,OAAO,UAACC,IAAY,EAAEC,OAAe,EAAK;IACxC,IAAI,CAACF,WAAW,CAACC,IAAI,CAAC,EAAE;MACtBD,WAAW,CAACC,IAAI,CAAC,GAAG,IAAAE,eAAQ,EAACD,OAAO,CAAC;IACvC;IACA,OAAOF,WAAW,CAACC,IAAI,CAAC;EAC1B,CAAC;AACH,CAAC,CAAE,CAAC;AAKG,IAAMG,aAAa,GAAG;EAAEC,MAAM,EAANA,MAAM;EAAEC,mBAAmB,EAAnBA;AAAoB,CAAC;AAACC,OAAA,CAAAH,aAAA,GAAAA,aAAA;AAKtD,IAAMI,qBAAqB,GAAG,SAAxBA,qBAAqBA,CAChCP,IAA0B,EAC1BQ,UAAkB,EAClBC,cAAyC,EACvB;EAClB,IAAAC,cAAA,GAII,IAAAC,8BAAa,EAACX,IAAI,CAAC;IAHrBC,OAAO,GAAAS,cAAA,CAAPT,OAAO;IACPW,QAAQ,GAAAF,cAAA,CAARE,QAAQ;IAAAC,qBAAA,GAAAH,cAAA,CACRI,SAAS;IAATA,SAAS,GAAAD,qBAAA,cAAG,UAACE,IAAmB;MAAA,OAAKA,IAAI;IAAA,IAAAF,qBAAA;EAE3C,IAAIL,UAAU,KAAK,EAAE,EAAE;IACrB,OAAOI,QAAQ;EACjB;EACA,IAAI;IACF,IAAMI,MAAM,GAAGlB,cAAc,CAACE,IAAI,EAAEC,OAAO,CAAC;IAC5C,IAAMgB,UAA+B,GAAG,CACtC,IAAAC,8CAAsB,EAACT,cAAc,CAAC,EACtCK,SAAS,CACV;IACD,OAAO,IAAAK,2BAAY,EAACH,MAAM,CAACI,KAAK,CAACZ,UAAU,EAAEL,aAAa,CAAC,EAAEc,UAAU,CAAC;EAC1E,CAAC,CAAC,OAAOI,KAAK,EAAE;IACd,OAAO,IAAAC,iDAAsB,EAACd,UAAU,CAAC;EAC3C;AACF,CAAC;AAACF,OAAA,CAAAC,qBAAA,GAAAA,qBAAA"}
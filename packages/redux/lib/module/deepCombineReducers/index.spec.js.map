{"version":3,"file":"index.spec.js","names":["deepCombineReducers","test","reducer","state","expect","toBe","a","b","combined","type","toEqual","c","nested","reducerAndNested","notNested","initialState"],"sources":["../../../src/deepCombineReducers/index.spec.tsx"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\n\nimport type { DeepReducersMapObject } from '.'\nimport { deepCombineReducers } from '.'\n\ntest('should handle plain function reducers', () => {\n  const reducer = (state: any) => state\n  expect(deepCombineReducers(reducer)).toBe(reducer)\n})\n\ntest('should handle reducer object maps', () => {\n  interface IState {\n    a?: string\n    b?: string\n  }\n  const reducer = {\n    a: () => 'a',\n    b: () => 'b',\n  }\n  const combined = deepCombineReducers<IState>(reducer)\n  expect(combined({}, { type: 'init' })).toEqual({ a: 'a', b: 'b' })\n})\n\ntest('should handle recursive reducer object maps', () => {\n  interface IState {\n    a?: string\n    b?: string\n    c?: {\n      nested?: string\n    }\n  }\n  const reducer = {\n    a: () => 'a',\n    b: () => 'b',\n    c: {\n      nested: () => 'nested',\n    },\n  }\n  const combined = deepCombineReducers<IState>(reducer)\n  expect(combined({}, { type: 'init' })).toEqual({\n    a: 'a',\n    b: 'b',\n    c: { nested: 'nested' },\n  })\n})\n\ntest('should handle reducers that are both functions and nested objects', () => {\n  interface IState {\n    a?: string\n    b?: string\n    c?: {\n      nested?: string\n      notNested?: string\n    }\n  }\n  const reducerAndNested = ((state: Record<string, unknown>) => {\n    return { ...state, notNested: 'notNested' }\n  }) as DeepReducersMapObject<IState['c']>\n  reducerAndNested!.nested = () => 'nested'\n  const reducer = {\n    a: () => 'a',\n    b: () => 'b',\n    c: reducerAndNested,\n  }\n  const initialState = {\n    a: 'initiala',\n    b: 'initialb',\n    c: {},\n  }\n  const combined = deepCombineReducers<IState>(reducer)\n  expect(combined(initialState, { type: 'init' })).toEqual({\n    a: 'a',\n    b: 'b',\n    c: { notNested: 'notNested', nested: 'nested' },\n  })\n})\n"],"mappings":";;;;AAMA,SAASA,mBAAmB,QAAQ,GAAG;AAEvCC,IAAI,CAAC,uCAAuC,EAAE,MAAM;EAClD,MAAMC,OAAO,GAAIC,KAAU,IAAKA,KAAK;EACrCC,MAAM,CAACJ,mBAAmB,CAACE,OAAO,CAAC,CAAC,CAACG,IAAI,CAACH,OAAO,CAAC;AACpD,CAAC,CAAC;AAEFD,IAAI,CAAC,mCAAmC,EAAE,MAAM;EAK9C,MAAMC,OAAO,GAAG;IACdI,CAAC,EAAE,MAAM,GAAG;IACZC,CAAC,EAAE,MAAM;EACX,CAAC;EACD,MAAMC,QAAQ,GAAGR,mBAAmB,CAASE,OAAO,CAAC;EACrDE,MAAM,CAACI,QAAQ,CAAC,CAAC,CAAC,EAAE;IAAEC,IAAI,EAAE;EAAO,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC;IAAEJ,CAAC,EAAE,GAAG;IAAEC,CAAC,EAAE;EAAI,CAAC,CAAC;AACpE,CAAC,CAAC;AAEFN,IAAI,CAAC,6CAA6C,EAAE,MAAM;EAQxD,MAAMC,OAAO,GAAG;IACdI,CAAC,EAAE,MAAM,GAAG;IACZC,CAAC,EAAE,MAAM,GAAG;IACZI,CAAC,EAAE;MACDC,MAAM,EAAE,MAAM;IAChB;EACF,CAAC;EACD,MAAMJ,QAAQ,GAAGR,mBAAmB,CAASE,OAAO,CAAC;EACrDE,MAAM,CAACI,QAAQ,CAAC,CAAC,CAAC,EAAE;IAAEC,IAAI,EAAE;EAAO,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC;IAC7CJ,CAAC,EAAE,GAAG;IACNC,CAAC,EAAE,GAAG;IACNI,CAAC,EAAE;MAAEC,MAAM,EAAE;IAAS;EACxB,CAAC,CAAC;AACJ,CAAC,CAAC;AAEFX,IAAI,CAAC,mEAAmE,EAAE,MAAM;EAS9E,MAAMY,gBAAgB,GAAKV,KAA8B,IAAK;IAC5D,uCAAYA,KAAK;MAAEW,SAAS,EAAE;IAAW;EAC3C,CAAwC;EACxCD,gBAAgB,CAAED,MAAM,GAAG,MAAM,QAAQ;EACzC,MAAMV,OAAO,GAAG;IACdI,CAAC,EAAE,MAAM,GAAG;IACZC,CAAC,EAAE,MAAM,GAAG;IACZI,CAAC,EAAEE;EACL,CAAC;EACD,MAAME,YAAY,GAAG;IACnBT,CAAC,EAAE,UAAU;IACbC,CAAC,EAAE,UAAU;IACbI,CAAC,EAAE,CAAC;EACN,CAAC;EACD,MAAMH,QAAQ,GAAGR,mBAAmB,CAASE,OAAO,CAAC;EACrDE,MAAM,CAACI,QAAQ,CAACO,YAAY,EAAE;IAAEN,IAAI,EAAE;EAAO,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC;IACvDJ,CAAC,EAAE,GAAG;IACNC,CAAC,EAAE,GAAG;IACNI,CAAC,EAAE;MAAEG,SAAS,EAAE,WAAW;MAAEF,MAAM,EAAE;IAAS;EAChD,CAAC,CAAC;AACJ,CAAC,CAAC"}
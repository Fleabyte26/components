{"version":3,"file":"index.spec.js","names":["test","reducer","state","expect","deepCombineReducers","toBe","a","b","combined","type","toEqual","c","nested","reducerAndNested","notNested","initialState"],"sources":["../../../src/deepCombineReducers/index.spec.tsx"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\n\nimport type { DeepReducersMapObject } from '.'\nimport { deepCombineReducers } from '.'\n\ntest('should handle plain function reducers', () => {\n  const reducer = (state: any) => state\n  expect(deepCombineReducers(reducer)).toBe(reducer)\n})\n\ntest('should handle reducer object maps', () => {\n  interface IState {\n    a?: string\n    b?: string\n  }\n  const reducer = {\n    a: () => 'a',\n    b: () => 'b',\n  }\n  const combined = deepCombineReducers<IState>(reducer)\n  expect(combined({}, { type: 'init' })).toEqual({ a: 'a', b: 'b' })\n})\n\ntest('should handle recursive reducer object maps', () => {\n  interface IState {\n    a?: string\n    b?: string\n    c?: {\n      nested?: string\n    }\n  }\n  const reducer = {\n    a: () => 'a',\n    b: () => 'b',\n    c: {\n      nested: () => 'nested',\n    },\n  }\n  const combined = deepCombineReducers<IState>(reducer)\n  expect(combined({}, { type: 'init' })).toEqual({\n    a: 'a',\n    b: 'b',\n    c: { nested: 'nested' },\n  })\n})\n\ntest('should handle reducers that are both functions and nested objects', () => {\n  interface IState {\n    a?: string\n    b?: string\n    c?: {\n      nested?: string\n      notNested?: string\n    }\n  }\n  const reducerAndNested = ((state: Record<string, unknown>) => {\n    return { ...state, notNested: 'notNested' }\n  }) as DeepReducersMapObject<IState['c']>\n  reducerAndNested!.nested = () => 'nested'\n  const reducer = {\n    a: () => 'a',\n    b: () => 'b',\n    c: reducerAndNested,\n  }\n  const initialState = {\n    a: 'initiala',\n    b: 'initialb',\n    c: {},\n  }\n  const combined = deepCombineReducers<IState>(reducer)\n  expect(combined(initialState, { type: 'init' })).toEqual({\n    a: 'a',\n    b: 'b',\n    c: { notNested: 'notNested', nested: 'nested' },\n  })\n})\n"],"mappings":";;;;AAMA;AAAuC;AAAA;AAEvCA,IAAI,CAAC,uCAAuC,EAAE,YAAM;EAClD,IAAMC,OAAO,GAAG,SAAVA,OAAO,CAAIC,KAAU;IAAA,OAAKA,KAAK;EAAA;EACrCC,MAAM,CAAC,IAAAC,qBAAmB,EAACH,OAAO,CAAC,CAAC,CAACI,IAAI,CAACJ,OAAO,CAAC;AACpD,CAAC,CAAC;AAEFD,IAAI,CAAC,mCAAmC,EAAE,YAAM;EAK9C,IAAMC,OAAO,GAAG;IACdK,CAAC,EAAE;MAAA,OAAM,GAAG;IAAA;IACZC,CAAC,EAAE;MAAA,OAAM,GAAG;IAAA;EACd,CAAC;EACD,IAAMC,QAAQ,GAAG,IAAAJ,qBAAmB,EAASH,OAAO,CAAC;EACrDE,MAAM,CAACK,QAAQ,CAAC,CAAC,CAAC,EAAE;IAAEC,IAAI,EAAE;EAAO,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC;IAAEJ,CAAC,EAAE,GAAG;IAAEC,CAAC,EAAE;EAAI,CAAC,CAAC;AACpE,CAAC,CAAC;AAEFP,IAAI,CAAC,6CAA6C,EAAE,YAAM;EAQxD,IAAMC,OAAO,GAAG;IACdK,CAAC,EAAE;MAAA,OAAM,GAAG;IAAA;IACZC,CAAC,EAAE;MAAA,OAAM,GAAG;IAAA;IACZI,CAAC,EAAE;MACDC,MAAM,EAAE;QAAA,OAAM,QAAQ;MAAA;IACxB;EACF,CAAC;EACD,IAAMJ,QAAQ,GAAG,IAAAJ,qBAAmB,EAASH,OAAO,CAAC;EACrDE,MAAM,CAACK,QAAQ,CAAC,CAAC,CAAC,EAAE;IAAEC,IAAI,EAAE;EAAO,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC;IAC7CJ,CAAC,EAAE,GAAG;IACNC,CAAC,EAAE,GAAG;IACNI,CAAC,EAAE;MAAEC,MAAM,EAAE;IAAS;EACxB,CAAC,CAAC;AACJ,CAAC,CAAC;AAEFZ,IAAI,CAAC,mEAAmE,EAAE,YAAM;EAS9E,IAAMa,gBAAgB,GAAI,SAApBA,gBAAgB,CAAKX,KAA8B,EAAK;IAC5D,uCAAYA,KAAK;MAAEY,SAAS,EAAE;IAAW;EAC3C,CAAwC;EACxCD,gBAAgB,CAAED,MAAM,GAAG;IAAA,OAAM,QAAQ;EAAA;EACzC,IAAMX,OAAO,GAAG;IACdK,CAAC,EAAE;MAAA,OAAM,GAAG;IAAA;IACZC,CAAC,EAAE;MAAA,OAAM,GAAG;IAAA;IACZI,CAAC,EAAEE;EACL,CAAC;EACD,IAAME,YAAY,GAAG;IACnBT,CAAC,EAAE,UAAU;IACbC,CAAC,EAAE,UAAU;IACbI,CAAC,EAAE,CAAC;EACN,CAAC;EACD,IAAMH,QAAQ,GAAG,IAAAJ,qBAAmB,EAASH,OAAO,CAAC;EACrDE,MAAM,CAACK,QAAQ,CAACO,YAAY,EAAE;IAAEN,IAAI,EAAE;EAAO,CAAC,CAAC,CAAC,CAACC,OAAO,CAAC;IACvDJ,CAAC,EAAE,GAAG;IACNC,CAAC,EAAE,GAAG;IACNI,CAAC,EAAE;MAAEG,SAAS,EAAE,WAAW;MAAEF,MAAM,EAAE;IAAS;EAChD,CAAC,CAAC;AACJ,CAAC,CAAC"}